//
//  main.cpp
//  Two_Body_Problem
//
//  Created by Zackary Windham on 3/2/20.
//  Copyright Â© 2020 Zackary Windham. All rights reserved.
//

#include <boost/numeric/odeint.hpp>
#include <boost/numeric/odeint/stepper/controlled_runge_kutta.hpp>
#include <boost/numeric/odeint/stepper/controlled_step_result.hpp>
#include <boost/array.hpp>
#include <boost/config.hpp>
#include <iostream>
#include <fstream>
#include <ctime>
#include <cstdlib>

#include "structs.h"

using namespace std;
using namespace boost::numeric::odeint;

int main(int argc, const char * argv[]) {
    
    srand (static_cast <unsigned> (time(0)));
    
    //make sure the files are there and all work
    if (argc < 4)
    {
        cerr << "Please provide an input file generated by TWO_BODY_RUNSCRIPT.py, then two csv files for the output of both bodies." << endl;
        return 1;
    }
    ifstream inputFile(argv[1]);
    if (!inputFile)
    {
        cerr << "Unable to open " << argv[1] << " for input." << endl;
        return 2;
    }
    ofstream firstBody;
    firstBody.open(argv[2], ofstream::out | ofstream::trunc);
    if (!firstBody)
    {
        cerr << "Unable to open " << argv[2] << " for output." << endl;
        return 3;
    }
    ofstream secondBody;
    secondBody.open(argv[3], ofstream::out | ofstream::trunc);
    if (!secondBody)
    {
        cerr << "Unable to open " << argv[3] << " for output." << endl;
        return 4;
    }
    
    //Get the units that this is using, set up a conversion factor from arbitrary units to SI units for momentum and kinetic energy
    string dataLine;
    getline(inputFile, dataLine);
    stringstream iss1(dataLine);
    double G_SCALED, M, L, T;
    iss1 >> G_SCALED >> M >> L >> T;
    
    double pUnits = M * L / T;
    double KEUnits = pUnits * L / T;
    
    //Grab the parameters for the first body and initialize the first body
    getline(inputFile, dataLine);
    stringstream iss2(dataLine);
    double MASS_1, x1, y1, z1, p1X, p1Y, p1Z;
    iss2 >> MASS_1 >> x1 >> y1 >> z1 >> p1X >> p1Y >> p1Z;
    
    //Do the same for the second body
    getline(inputFile, dataLine);
    stringstream iss3(dataLine);
    double MASS_2, x2, y2, z2, p2X, p2Y, p2Z;
    iss3 >> MASS_2 >> x2 >> y2 >> z2 >> p2X >> p2Y >> p2Z;
    
    double mult_factor = MASS_1 / 100000.0;
    double extra_masses[n - 2];
    double extra_x[n - 2];
    double extra_y[n - 2];
    double extra_z[n - 2];
    double extra_px[n - 2];
    double extra_py[n - 2];
    double extra_pz[n - 2];
    
    for(unsigned int i = 0; i < n - 2; ++i)
    {
        double val = static_cast<double>(rand()) / static_cast<double>(RAND_MAX);
        extra_masses[i] = val * mult_factor;
    }
    
    for(unsigned int i = 0; i < n - 2; ++i)
    {
        double val = static_cast<double>(rand()) / static_cast<double>(RAND_MAX);
        extra_x[i] = (2 * val) - 1;
    }
    
    for(unsigned int i = 0; i < n - 2; ++i)
    {
        double val = static_cast<double>(rand()) / static_cast<double>(RAND_MAX);
        extra_y[i] = (2 * val) - 1;
    }
    
    for(unsigned int i = 0; i < n - 2; ++i)
    {
        double val = static_cast<double>(rand()) / static_cast<double>(RAND_MAX);
        extra_z[i] = (2 * val) - 1;
    }
    
    for(unsigned int i = 0; i < n - 2; ++i)
    {
        double val = static_cast<double>(rand()) / static_cast<double>(RAND_MAX);
        extra_px[i] = (10 * val) - 5;
    }
    
    for(unsigned int i = 0; i < n - 2; ++i)
    {
        double val = static_cast<double>(rand()) / static_cast<double>(RAND_MAX);
        extra_py[i] = (10 * val) - 5;
    }
    
    for(unsigned int i = 0; i < n - 2; ++i)
    {
        double val = static_cast<double>(rand()) / static_cast<double>(RAND_MAX);
        extra_pz[i] = (10 * val) - 5;
    }
    
    mass_type masses;
    masses[0] = MASS_1;
    masses[1] = MASS_2;
    for (unsigned int i = 2; i < n; i++)
    {
        masses[i] = extra_masses[i - 2];
    }
    
    container_type q;
    q[0] = point_type(x1, y1, z1);
    q[1] = point_type(x2, y2, z2);
    for (unsigned int i = 2; i < n; i++)
    {
        double xi = extra_x[i];
        double yi = extra_y[i];
        double zi = extra_z[i];
        q[i] = point_type(xi, yi, zi);
    }
    
    container_type p;
    p[0] = point_type(p1X, p1Y, p1Z);
    p[1] = point_type(p2X, p2Y, p2Z);
    for (unsigned int i = 2; i < n; i++)
    {
        double pxi = extra_px[i];
        double pyi = extra_py[i];
        double pzi = extra_pz[i];
        q[i] = point_type(pxi, pyi, pzi);
    }
    
    //typedef controlled_runge_kutta<runge_kutta_fehlberg78>  stepper_type;
    //typedef runge_kutta4<container_type> stepper_type;
    typedef symplectic_rkn_sb3a_mclachlan<container_type> stepper_type;
    const double dt = .1;
    
    integrate_const(
                    stepper_type(),
                    make_pair(coor(masses, G_SCALED, q), momentum(masses, G_SCALED, p)),
                    make_pair(boost::ref(q), boost::ref(p)),
                    0.0, 20000.0, dt, output(firstBody));

    return 0;
}
